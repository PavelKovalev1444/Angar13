#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

//printCurrentDate работает, первая функция готова
//minAndMaxDate работает, четвертая функция работает

struct Sentences{ //структура текста
    char* sentence;
    time_t minTime;
    time_t maxTime;
    char minimalData[11];
    char maximalData[11];
};

char* ReadSentence(); //считывание предложения

char* DelProbel(char* s); // удаление пробела и табуляции в начале предложения

int DoubleSentence(char** arr, int* n); // удаление повторяющихся предложений

struct tm parseDate(char *str); // перевод даты во временной штамп

void printCurrentDate(char** arr, int n); // первая функция - вывод предложений с текущим месяцем и годом

void minAndMaxData(struct Sentences* ptr, int n); // вывод максимальной и минимальной дат

//time_t* viktorianDates(); вычисление временных штампов для диапазона девятнадцатаго века

int searchViktorian(char* sentence);// поиск предложения с викторианскими датами

void deleterViktorians(char** arr, int* n);// удаление предложений с викторианскими датами

int comparator(const void* a, const void* b);

int main(){
    char** arr = malloc(10*sizeof(char*));
    int size = 10;
    int n = 0; //кол-во предложений
    char* s;//указатель на считываемое предложение
    //считывание предложений
    while(1){
        s = ReadSentence();
        if(strcmp(s, "\n") == 0){
            break;
        }
        if(n == size -1) {
            size += 10;
            arr = realloc(arr, sizeof(char *) * size);
        }
        arr[n] = DelProbel(s);
        n++;
    }
    DoubleSentence(arr, &n);
    //удалил повторяющиеся предложения, работаю со структурой
    struct Sentences text;
    struct Sentences* pointer = malloc(n*sizeof(struct Sentences));
    for(int i = 0; i < n; i++){
        pointer[i].sentence = arr[i];
    }
    //вторая функция
    //minAndMaxData(pointer, n);
    //for(int i = 0; i < n; i++){
    //	printf("[%s]\n", pointer[i].maximalData);
    //}
    //deleterViktorians(arr, &n);
    /*---------------------------------------------------*/
    printf("\n\n\tЗдравствуйте! Вы можете выбрать следующие функции: 1 - вывод предложений с текущим месяцем и годом. 2 - сортировка предложений по увеличению минимальной даты. 3 - удаление предложений, состоящих из дат 19го века, 4 - вывод минимальной и максимальной дат для каждого предложения.\n\n");
    int operationSelect;
    scanf("%d", &operationSelect);
    printf("Выбрана функция: %d\n", operationSelect);
    switch(operationSelect){
    	case 1:
		printf("Выбрана функция вывода предложений, в которых есть дата с текущим годом и месяцем.\n\n");
		printCurrentDate(arr, n);
		break;
	case 2:
		printf("Выбрана функция сортировки предложений по увеличению минимальной даты.\n\n");
		
		break;
	case 3:
		printf("Выбрана функция удаления предложений, которые состоят из дат 19го века.\n\n");
		
		break;
	case 4:
		printf("Выбрана функция вывода минимальной и максимальной дат для каждого предложения.\n\n");
		minAndMaxData(pointer, n);
		break;
	default:
		printf("Функция выбрана неправильно. Попробуйте снова.\n\n");
		return 0;	
    }
    /*
    printf("\n\n---------------------------------------------\n");//вывод текста через массив
    for(int i = 0; i<n; i++){
        printf("|\t\t\t[%s]\t\t\t\t\t|\n", arr[i]);
    }
    */
    for(int i = 0; i < n; i++){//очистка памяти
        free(arr[i]);
    }
    free(arr);
    free(s);
    return 0;
}

char* ReadSentence()
{
    char* s = malloc(10*sizeof(char));
    int n = 0;
    char c;
    int size = 10;
    while((c = getchar()) && c != '.' && c != '\n'){
        if(n == (size-2)){
            size += 10;
            s = realloc(s, size);
        }
        s[n] = c;
        ++n;
    }
    s[n] = c;
    s[n+1] = '\0';
    return s;
}

char* DelProbel(char* s)
{
    int i = 0;
    int length = strlen(s);
    if((s[0] == ' ') || (s[0] == '\t')){
        while(i < length){
            s[i] = s[i+1];
            i++;
        }
    }
    return s;
}

int DoubleSentence(char** arr, int *n)
{
    int i = 0;
    int length = 0;
    length = *n;
    while(i < length - 1){
        for(int j = i + 1; j < length; j++){
            if(strcmp(arr[i], arr[j]) == 0){
                free(arr[j]);
                for(int a = j; a < length - 1; a++){
                    arr[a] = arr[a+1];
                }
                length--;
                *n-=1;
                j--;
            }
        }
        i++;
    }
}

struct tm parseDate(char *str)
{
    int year, mon, day;
    sscanf(str, "%d/%d/%d", &day, &mon, &year);
    struct tm time;
    memset(&time, 0, sizeof(time));
    time.tm_mon = mon - 1;
    time.tm_mday = day;
    time.tm_year = year - 1900;
    time.tm_isdst = -1;
    return time;
}

void printCurrentDate(char** arr, int n)
{
    for(int i = 0; i < n; i++) {
        char *buffer = calloc(strlen(arr[i]) + 1, sizeof(char));
        strcpy(buffer, arr[i]);
        char *istr;
        istr = strtok(buffer, " ");
        int count = 0;
        struct tm data_input;
        time_t now_time;
        time(&now_time);
        struct tm* data_now;
        data_now = localtime(&now_time);
        while(istr != NULL){
            data_input = parseDate(istr);
            if(data_input.tm_year == data_now->tm_year && data_input.tm_mon == data_now->tm_mon){
                count++;
            }
            istr = strtok(NULL, " ");
        }
        if(count > 0){
            printf("[%s]\n", arr[i]);
        }
    }
}

void minAndMaxData(struct Sentences *ptr, int n) {
    int sentenceLength;
    for(int i = 0; i < n; i++){
        int indexOfMinimal = 0, indexOfMaximal = 0;
        int countOfWords = 1;
        sentenceLength = strlen((ptr + i)->sentence);
        for(int k = 0; k < sentenceLength; k++) {
            if ((ptr + i)->sentence[k] == ' '){
                countOfWords++;
            }
        }
        char buf[sentenceLength];
        strcpy(buf, (ptr+i)->sentence);
        char** arraySentences = malloc(countOfWords*sizeof(char*));
        for(int k = 0; k < countOfWords; k++){
            arraySentences[k] = malloc(11*sizeof(char));
        }
        arraySentences[0] = strtok(buf, " .");
        for(int k = 1; k < countOfWords; k++){
            arraySentences[k] = strtok(NULL, " .");
        }
        time_t times[countOfWords];
        for(int k = 0; k < countOfWords; k++){
            struct tm dateTime;
            dateTime = parseDate(arraySentences[k]);
            time_t timeOfDate = mktime(&dateTime);
            times[k] = timeOfDate;
        }
        time_t MIN = times[0];
        time_t MAX = times[0];
        for(int k = 1; k < countOfWords; k++){
            if(times[k] < MIN){
                MIN = times[k];
                indexOfMinimal = k;
            }
            if(times[k] > MAX){
                MAX = times[k];
                indexOfMaximal = k;
            }
        }
        (ptr+i)->minTime = MIN;
        strcpy((ptr + i) -> minimalData, arraySentences[indexOfMinimal]);
        strcpy((ptr + i) -> maximalData, arraySentences[indexOfMaximal]);
    }
    for(int i = 0; i < n; i++){
    	printf("[%s] -  {%s} -  {%s}\n\n", (ptr+i)->sentence, (ptr+i)->minimalData, (ptr+i)->maximalData );
    }
}


/*
time_t* viktorianDates(){ //вычисляю диапазон девятнадцатаго века во временном штампе
	char* viktorianMin;
	viktorianMin = "01/01/1801";
	char* viktorianMax;
	viktorianMax = "31/12/1900";
	struct tm vikMin = parseDate(viktorianMin);	
	struct tm vikMax = parseDate(viktorianMax);
	time_t minimalViktorian = mktime(&vikMin);
	time_t maximalViktorian = mktime(&vikMax);
	time_t viktorianArray[2];
	viktorianArray[0] = minimalViktorian;
        viktorianArray[1] = maximalViktorian;
	return viktorianArray;
}
*/


int searchViktorian(char* sentence){ // поиск предложений с викторианскими датами
	char* viktorianMin;
        viktorianMin = "01/01/1801";
        char* viktorianMax;
        viktorianMax = "31/12/1900";
        struct tm vikMin = parseDate(viktorianMin);
        struct tm vikMax = parseDate(viktorianMax);
        time_t minimalViktorian = mktime(&vikMin);
        time_t maximalViktorian = mktime(&vikMax);
        time_t viktorianArray[2];
        viktorianArray[0] = minimalViktorian;
        viktorianArray[1] = maximalViktorian;
//--------------------------------------------------	
	int sentenceLength;
	int countOfWords = 1;
	sentenceLength = strlen(sentence);
	char buf[sentenceLength];//копия предложения
	strcpy(buf, sentence);
	for(int k = 0; k < sentenceLength; k++){
		if(buf[k] == ' '){
			countOfWords++;
		}
	}
	//создание массива дат из предложения
	char** arrayOfDates = malloc(countOfWords*sizeof(char*));
        for(int k = 0; k < countOfWords; k++){
               	arrayOfDates[k] = malloc(11*sizeof(char));
        }
	arrayOfDates[0] = strtok(sentence, " .");
	for(int k = 1; k < countOfWords; k++){
		arrayOfDates[k] = strtok(NULL, " .");
	}
	//создание массива временных штампов, соответствующих каждой дате предложения
	time_t times[countOfWords];
        for(int k = 0; k < countOfWords; k++){
        	struct tm dateTime;
         	dateTime = parseDate(arrayOfDates[k]);
            	time_t timeOfDate = mktime(&dateTime);
            	times[k] = timeOfDate;
        }
//викторианский диапазон
	int counter = 0;
	for(int k = 0; k < countOfWords; k++){
		if((times[k] >= viktorianArray[0]) || (times[k] <= viktorianArray[1])){
			counter++;
		}
	}
	if(counter == countOfWords){
		return 1;
	}
	return 0;
}

void deleterViktorians(char** arr, int* n){
	int i = 0;
	while(i < *n){
		if(searchViktorian(arr[i]) == 1){
			for(int k = i; k < *n - 1; k++){
				arr[k] = arr[k+1];
			}
			*n-=1;
		}
	}
}

int comparator(const void* a, const void* b){
	if( (((struct Sentences*)a)->minTime) < (((struct Sentences*)b)->minTime) ) return -1;
	if( (((struct Sentences*)a)->minTime) == (((struct Sentences*)b)->minTime) ) return 0;
	if( (((struct Sentences*)a)->minTime) > (((struct Sentences*)b)->minTime) ) return 1;	
}

void sorting(char** array, int n){
	
}

