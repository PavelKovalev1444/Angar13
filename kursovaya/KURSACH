#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

//printCurrentDate работает, первая функция готова
//minAndMaxDate работает, четвертая функция работает

struct Sentences{
    char* sentence;
    time_t minTime;
    time_t maxTime;
    char minimalData[11];
    char maximalData[11];
};

struct tm parse_date(char *str);

char* ReadSentence();

char* DelProbel(char* s);

int DoubleSentence(char** arr, int* n);

struct tm parse_date(char *str);

void printCurrentDate(char** arr, int n);

void minAndMaxData(struct Sentences* ptr, int n);

int main(){
    char** arr = malloc(10*sizeof(char*));
    int size = 10;
    int n = 0; //кол-во предложений
    char* s;//указатель на считываемое предложение
    //считывание предложений
    while(1){
        s = ReadSentence();
        if(strcmp(s, "\n") == 0){
            break;
        }
        if(n == size -1) {
            size += 10;
            arr = realloc(arr, sizeof(char *) * size);
        }
        arr[n] = DelProbel(s);
        n++;
    }
    DoubleSentence(arr, &n);
    //удалил повторяющиеся предложения, работаю со структурой
    struct Sentences text;

    struct Sentences* pointer = malloc(n*sizeof(struct Sentences));

    for(int i = 0; i < n; i++){
        pointer[i].sentence = arr[i];
    }
    //вторая функция
    minAndMaxData(pointer, n);
    for(int i = 0; i < n; i++){
    	printf("[%s]\n", pointer[i].maximalData);
    }
    //первая функция
    			//printCurrentDate(arr, n);
    //первая функция
    printf("\n\n---------------------------------------------\n");
    for(int i = 0; i<n; i++){
        printf("|\t\t\t[%s]\t\t\t\t\t|\n", arr[i]);
    }
    for(int i = 0; i < n; i++){
        free(arr[i]);
    }
    free(arr);
    free(s);
    return 0;
}

char* ReadSentence()
{
    char* s = malloc(10*sizeof(char));
    int n = 0;
    char c;
    int size = 10;
    while((c = getchar()) && c != '.' && c != '\n'){
        if(n == (size-2)){
            size += 10;
            s = realloc(s, size);
        }
        s[n] = c;
        ++n;
    }
    s[n] = c;
    s[n+1] = '\0';
    return s;
}

char* DelProbel(char* s)
{
    int i = 0;
    int length = strlen(s);
    if((s[0] == ' ') || (s[0] == '\t')){
        while(i < length){
            s[i] = s[i+1];
            i++;
        }
    }
    return s;
}

int DoubleSentence(char** arr, int *n)
{
    int i = 0;
    int length = 0;
    length = *n;
    while(i < length - 1){
        for(int j = i + 1; j < length; j++){
            if(strcmp(arr[i], arr[j]) == 0){
                free(arr[j]);
                for(int a = j; a < length - 1; a++){
                    arr[a] = arr[a+1];
                }
                length--;
                *n-=1;
                j--;
            }
        }
        i++;
    }
}

struct tm parse_date(char *str)
{
    int year, mon, day;
    sscanf(str, "%d/%d/%d", &day, &mon, &year);
    struct tm time;
    memset(&time, 0, sizeof(time));
    time.tm_mon = mon - 1;
    time.tm_mday = day;
    time.tm_year = year - 1900;
    time.tm_isdst = -1;
    return time;
}

void printCurrentDate(char** arr, int n)
{
    for(int i = 0; i < n; i++) {
        char *buffer = calloc(strlen(arr[i]) + 1, sizeof(char));
        strcpy(buffer, arr[i]);
        char *istr;
        istr = strtok(buffer, " ");
        int count = 0;
        struct tm data_input;
        time_t now_time;
        time(&now_time);
        struct tm* data_now;
        data_now = localtime(&now_time);
        while(istr != NULL){
            data_input = parse_date(istr);
            if(data_input.tm_year == data_now->tm_year && data_input.tm_mon == data_now->tm_mon){
                count++;
            }
            istr = strtok(NULL, " ");
        }
        if(count > 0){
            printf("[%s]\n", arr[i]);
        }
    }
}

void minAndMaxData(struct Sentences *ptr, int n) {
    int sentenceLength;
    for(int i = 0; i < n; i++){
        int indexOfMinimal = 0, indexOfMaximal = 0;
        int countOfWords = 1;
        sentenceLength = strlen((ptr + i)->sentence);
        for(int k = 0; k < sentenceLength; k++) {
            if ((ptr + i)->sentence[k] == ' '){
                countOfWords++;
            }
        }
        char buf[sentenceLength];
        strcpy(buf, (ptr+i)->sentence);
        char** arraySentences = malloc(countOfWords*sizeof(char*));
        for(int k = 0; k < countOfWords; k++){
            arraySentences[k] = malloc(11*sizeof(char));
        }
        arraySentences[0] = strtok(buf, " .");
        for(int k = 1; k < countOfWords; k++){
            arraySentences[k] = strtok(NULL, " .");
        }
        time_t times[countOfWords];
        for(int k = 0; k < countOfWords; k++){
            struct tm dateTime;
            dateTime = parse_date(arraySentences[k]);
            time_t timeOfDate = mktime(&dateTime);
            times[k] = timeOfDate;
        }
        time_t MIN = times[0];
        time_t MAX = times[0];
        for(int k = 1; k < countOfWords; k++){
            if(times[k] < MIN){
                MIN = times[k];
                indexOfMinimal = k;
            }
            if(times[k] > MAX){
                MAX = times[k];
                indexOfMaximal = k;
            }
        }
        (ptr+i)->minTime = MIN;
        strcpy((ptr + i) -> minimalData, arraySentences[indexOfMinimal]);
        strcpy((ptr + i) -> maximalData, arraySentences[indexOfMaximal]);
    }
}
